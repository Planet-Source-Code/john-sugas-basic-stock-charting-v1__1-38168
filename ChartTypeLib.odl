[     //**************** Most of this code was plucked from 
	//****************** HardCore VB typeLib with some additions of my own                                                                              

//To Make Use:
//midl /nologo /D "_DEBUG" /o "NUL" /win32 /mktyplib203 /tlb PATH\charttypelib.TLB PATH\charttypelib.odl

// The Universal Unique identifier (UUID), needs to be generated by
// using uuidgen.exe program. Then, you paste the value into the type
// library.	///////////////**** GUIDGEN.exe ****


	uuid(C5C2DB70-A4BE-11d6-96DF-00D009D8E460),


// The Help String comes up in the object browser as the second
// piece of the library description in the "Libraries/Projects" combo
// box.

   helpstring("ChartTypeLib"),

// The Locale Identifier (LCID), identifies the language the type
// library applies to.

   lcid(0x9),

// This is the version number of the type library.

   version(1.0)

]

// This is the name of the type library. It comes up in the object
// browser as the first piece of the library description in the
// "Libraries/Projects" combo box.

   library ChartTypeLib

{

    importlib("stdole32.tlb");

// Define numeric constants.
// Note: String constants must be placed in a "module"... (further down the page)

typedef enum tagConst
{
WM_USER = 0x0400,
hNull = 0L,
WM_LBUTTONDOWN=0x201,
WM_LBUTTONUP=0x202,

MK_LBUTTON       = 0x0001,
MK_RBUTTON       = 0x0002,
MK_SHIFT         = 0x0004,
MK_CONTROL       = 0x0008,
MK_MBUTTON       = 0x0010,

VK_CONTROL    = 0x11,
VK_END        = 0x23,
VK_HOME       = 0x24,
VK_LEFT       = 0x25,
VK_RIGHT      = 0x27,
[ helpstring("Virtual key: Page Up") ]
VK_PRIOR      = 0x21,
[ helpstring("Virtual key: Page Down") ]
VK_NEXT       = 0x22,


TRANSPARENT = 1,  //need a comma behind all except the last entry
DT_CENTER = 1,
DT_RIGHT     = 0x0002,
DT_NOCLIP = 0x100,  //need to use the c notation for hex numbers... &H replaced by 0x
DT_VCENTER = 4,
DT_WORDBREAK = 0x10,

DEFAULT_QUALITY = 0, 		//' Appearance of the font is set to default
DRAFT_QUALITY = 1, 		//' Appearance is less important that PROOF_QUALITY.
PROOF_QUALITY = 2, 		//' Best character quality
NONANTIALIASED_QUALITY = 3, 	//' Don't smooth font edges even if system is set to smooth font edges
ANTIALIASED_QUALITY = 4, 	//' Ensure font edges are smoothed if system is set to smooth font edges
OUT_TT_PRECIS   = 4,
CLIP_CHARACTER_PRECIS   = 0x01,
CLIP_STROKE_PRECIS      = 0x02,
CLIP_MASK               = 0x0f,
CLIP_LH_ANGLES          = 0x04, // (1<<4)
CLIP_TT_ALWAYS          = 0x40,

GWL_HINSTANCE = -6,
WH_CBT = 5,
HCBT_ACTIVATE = 5,
SWP_NOZORDER = 0x4,
SWP_NOSIZE = 0x1,
SWP_NOOWNERZORDER = 0x200,      //'  Don't do owner Z ordering
SWP_NOREPOSITION = SWP_NOOWNERZORDER,
SWP_NOACTIVATE = 0x10,
GM_ADVANCED = 2,

DST_ICON = 3,
DSS_DISABLED = 32,
BDR_INNER = 0xC,
BDR_OUTER = 0x3,
BDR_RAISED = 0x5,
BDR_RAISEDINNER = 0x4,
BDR_RAISEDOUTER = 0x1,
BF_TOP = 0x2,
BF_RIGHT = 0x4,
BF_LEFT = 0x1,
BF_BOTTOM = 0x8,
BF_RECT = 15,     //(BF_LEFT Or BF_TOP Or BF_RIGHT Or BF_BOTTOM),
BF_TOPLEFT = 0x3,
BF_TOPRIGHT = 0x6,
BF_BOTTOMLEFT = 0x9,
BF_BOTTOMRIGHT = 0xC,
BF_MIDDLE = 0x800,    //' Fill in the middle.
EDGE_BUMP = 0x9,
EDGE_ETCHED = 0x6,
EDGE_RAISED = 0x5,
EDGE_SUNKEN = 0xA,

 // Ternary raster operations 
// Ternary raster operations
[ helpstring("BitBlt: Copy source bits over destination bits") ]
SRCCOPY     = 0x00CC0020, // dest = source
[ helpstring("BitBlt: OR source bits onto destination") ]
SRCPAINT    = 0x00EE0086, // dest = source OR dest
[ helpstring("BitBlt: AND source bits onto destination") ]
SRCAND      = 0x008800C6, // dest = source AND dest
[ helpstring("BitBlt: XOR source bits onto destination") ]
SRCINVERT   = 0x00660046, // dest = source XOR dest
[ helpstring("BitBlt: Invert destination bits, AND the result with source bits") ]
SRCERASE    = 0x00440328, // dest = source AND (NOT dest )
[ helpstring("BitBlt: Invert source bits, copy to destination") ]
NOTSRCCOPY  = 0x00330008, // dest = (NOT source)
[ helpstring("BitBlt: OR source bits onto destination bits, invert result") ]
NOTSRCERASE = 0x001100A6, // dest = (NOT src) AND (NOT dest)
[ helpstring("BitBlt: AND source bits onto pattern bits, copy to destination") ]
MERGECOPY   = 0x00C000CA, // dest = (source AND pattern)
[ helpstring("BitBlt: Invert source bits, AND result onto destination") ]
MERGEPAINT  = 0x00BB0226, // dest = (NOT source) OR dest
[ helpstring("BitBlt: Copy pattern bits over destination bits") ]
PATCOPY     = 0x00F00021, // dest = pattern
[ helpstring("BitBlt: Invert source bits, OR result with pattern, OR result with destination") ]
PATPAINT    = 0x00FB0A09, // dest = DPSnoo
[ helpstring("BitBlt: XOR pattern bits onto destination") ]
PATINVERT   = 0x005A0049, // dest = pattern XOR dest
[ helpstring("BitBlt: Invert destination bits") ]
DSTINVERT   = 0x00550009, // dest = (NOT dest)
[ helpstring("BitBlt: Turn destination bits black (0)") ]
BLACKNESS   = 0x00000042, // dest = BLACK
[ helpstring("BitBlt: Turn destination bits white (1)") ]
WHITENESS   = 0x00FF0062, // dest = WHITE


SM_CYCAPTION = 4,
SM_CYMENU = 15,

BI_RGB = 0L,  //force to long using "L"
DIB_RGB_COLORS = 0,    //'  color table in RGBs

VER_PLATFORM_WIN32_NT = 2,
VER_PLATFORM_WIN32_WINDOWS = 1,
VER_PLATFORM_WIN32s = 0,

//from hardcore vb
cMaxPath = 260,
cMaxFile = 260,
pNull = 0,
ERROR_BAD_PATHNAME = 161,
//FORMAT_MESSAGE_FROM_SYSTEM = 4096,
//FORMAT_MESSAGE_IGNORE_INSERTS = 512,
UnicodeTypeLib = -1,
GMEM_MOVEABLE = 0x2,
GMEM_ZEROINIT = 0x40,



// message from browser
      BFFM_INITIALIZED        = 1,
      BFFM_SELCHANGED         = 2,
      BFFM_VALIDATEFAILED     = 3,   // lParam:szPath ret:1(cont),0(EndDialog)


    // messages to browser
      BFFM_ENABLEOK           = WM_USER + 101,
      BFFM_SETSTATUSTEXT      = WM_USER + 100,
      BFFM_SETSELECTION       = WM_USER + 102,

//end hardcore

IPRTRMGR_PID = 10000,
ANY_SIZE = 1,


FILE_ATTRIBUTE_NORMAL    = 0x00000080,
FILE_FLAG_SEQUENTIAL_SCAN    = 0x08000000,
CREATE_ALWAYS        = 2,
GENERIC_WRITE   = 0x40000000,
hostent_size = 16,
INADDR_NONE = 0xFFFFFFFF,
INADDR_ANY = 0x0,
FD_CLOSE = 0x20,
FD_READ = 0x1,
SOCK_STREAM = 1,
AF_INET = 2,
MAX_WSADescription = 256,
MAX_WSASYSStatus = 128,
ERROR_SUCCESS        = 0,
INTERNET_CONNECTION_LAN  = 0x2L,
INTERNET_CONNECTION_MODEM  = 0x1L,
SOCKET_ERROR         = -1

}Constants;

typedef float FLOAT;
typedef double DOUBLE;
typedef void * PVOID, * LPVOID;

typedef enum PenStyle {
    PS_Solid = 0,
    PS_Dash = 1,       //' -------
    PS_Dot = 2,        //' .......
    PS_DashDot = 3,    //' _._._._
    PS_DashDotDot = 4, //' _.._.._
    PS_Null = 5
} PenStyle;

typedef enum Linetype {
  LT_Solid = 0,
  LT_Dash = 1,
  LT_Dot = 2,
  LT_Dashdot = 3,
  LT_Dashdotdot = 4,
  LT_Insideframe = 6,
  LT_None = 5
} Linetype;

typedef enum TicType {
    ttLine = 1,
    ttHLOC = 2,
    ttCandle = 3
} TicType;


//*******Structs
typedef struct POINTL {
    LONG   x;
    LONG   y;
} POINTL;

typedef struct POINTSINGLE {
    float   x;
    float   y;
} POINTSINGLE;

typedef struct RECT {
    LONG   Left;
    LONG   Top;
    LONG   Right;
    LONG   Bottom;
} RECT;

typedef struct SIZEL {
    LONG   cx;
    LONG   cy;
} SIZEL;

typedef struct DRAWTEXTPARAMS {
    LONG   cbSize;
    LONG   iTabLength;
    LONG   iLeftMargin;
    LONG   iRightMargin;
    LONG   uiLengthDrawn;
} DRAWTEXTPARAMS;

typedef struct SYSTEM_INFO {
        LONG   dwOemID;
        LONG   dwPageSize;
        LONG   lpMinimumApplicationAddress;
        LONG   lpMaximumApplicationAddress;
        LONG   dwActiveProcessorMask;
        LONG   dwNumberOfProcessors;
        LONG   dwProcessorType;
        LONG   dwAllocationGranularity;
        short   wProcessorLevel;
        short   wProcessorRevision;
} SYSTEM_INFO;

typedef struct MEMORYSTATUS {
    LONG   dwLength;
    LONG   dwMemoryLoad;
    LONG   dwTotalPhys;
    LONG   dwAvailPhys;
    LONG   dwTotalPageFile;
    LONG   dwAvailPageFile;
    LONG   dwTotalVirtual;
    LONG   dwAvailVirtual;
} MEMORYSTATUS;

typedef struct LARGE_INTEGER {
    LONG   lowpart;
    LONG   highpart;
} LARGE_INTEGER;

typedef struct RGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

typedef struct BITMAPINFOHEADER {
        LONG      biSize;
        LONG       biWidth;
        LONG       biHeight;
        short       biPlanes;
        short       biBitCount;
        LONG      biCompression;
        LONG      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        LONG      biClrUsed;
        LONG      biClrImportant;
} BITMAPINFOHEADER;

typedef struct BITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO;

typedef struct BITMAPFILEHEADER {
        short    bfType;
        LONG   bfSize;
        short    bfReserved1;
        short    bfReserved2;
        LONG   bfOffBits;
} BITMAPFILEHEADER;

/*
typedef struct LOGFONT {
    LONG   lfHeight;
    LONG   lfWidth;
    LONG   lfEscapement;
    LONG   lfOrientation;
    LONG   lfWeight;
    BYTE   lfItalic;
    BYTE   lfUnderline;
    BYTE   lfStrikeOut;
    BYTE   lfCharSet;
    BYTE   lfOutPrecision;
    BYTE   lfClipPrecision;
    BYTE   lfQuality;
    BYTE   lfPitchAndFamily;
    BYTE   lfFaceName[32];
} LOGFONT;
*/



//*********hardcode types
typedef struct OPENFILENAME {
    LONG   lStructSize;
    LONG   hwndOwner;
    LONG   hInstance;
    BSTR   lpstrFilter;
    BSTR   lpstrCustomFilter;
    LONG   nMaxCustFilter;
    LONG   nFilterIndex;
    BSTR   lpstrFile;
    LONG   nMaxFile;
    BSTR   lpstrFileTitle;
    LONG   nMaxFileTitle;
    BSTR   lpstrInitialDir;
    BSTR   lpstrTitle;
    LONG   Flags;
    short   nFileOffset;
    short   nFileExtension;
    BSTR   lpstrDefExt;
    LONG   lCustData;
    LONG   lpfnHook;
    BSTR   lpTemplateName;
} OPENFILENAME;
 
typedef enum EOpenFile {
    OFN_READONLY = 0x1,
    OFN_OVERWRITEPROMPT = 0x2,
    OFN_HIDEREADONLY = 0x4,
    OFN_NOCHANGEDIR = 0x8,
    OFN_SHOWHELP = 0x10,
    OFN_ENABLEHOOK = 0x20,
    OFN_ENABLETEMPLATE = 0x40,
    OFN_ENABLETEMPLATEHANDLE = 0x80,
    OFN_NOVALIDATE = 0x100,
    OFN_ALLOWMULTISELECT = 0x200,
    OFN_EXTENSIONDIFFERENT = 0x400,
    OFN_PATHMUSTEXIST = 0x800,
    OFN_FILEMUSTEXIST = 0x1000,
    OFN_CREATEPROMPT = 0x2000,
    OFN_SHAREAWARE = 0x4000,
    OFN_NOREADONLYRETURN = 0x8000,
    OFN_NOTESTFILECREATE = 0x10000,
    OFN_NONETWORKBUTTON = 0x20000,
    OFN_NOLONGNAMES = 0x40000,
    OFN_EXPLORER = 0x80000,
    OFN_NODEREFERENCELINKS = 0x100000,
    OFN_LONGNAMES = 0x200000
} EOpenFile;

typedef struct TCHOOSECOLOR {
    LONG   lStructSize;
    LONG   hwndOwner;
    LONG   hInstance;
    LONG   rgbResult;
    LONG   lpCustColors;
    LONG   Flags;
    LONG   lCustData;
    LONG   lpfnHook;
    BSTR   lpTemplateName;
} TCHOOSECOLOR;

typedef enum EChooseColor {
    CC_RGBINIT = 0x1,
    CC_FULLOPEN = 0x2,
    CC_PREVENTFULLOPEN = 0x4,
    CC_COLORSHOWHELP = 0x8,
    CC_ENABLEHOOK = 0x10,
    CC_ENABLETEMPLATE = 0x20,
    CC_ENABLETEMPLATEHANDLE = 0x40,
    CC_SOLIDCOLOR = 0x80,
    CC_ANYCOLOR = 0x100
} EChooseColor;


typedef struct TCHOOSEFONT {
    LONG   lStructSize;
    LONG   hwndOwner;
    LONG   hdc;
    LONG   lpLogFont;
    LONG   iPointSize;
    LONG   Flags;
    LONG   rgbColors;
    LONG   lCustData;
    LONG   lpfnHook;
    BSTR   lpTemplateName;
    LONG   hInstance;
    BSTR   lpszStyle;
    short   nFontType;
    short   iAlign;
    LONG   nSizeMin;
    LONG   nSizeMax;
} TCHOOSEFONT;

typedef enum EChooseFont {
    CF_SCREENFONTS = 0x1,
    CF_PRINTERFONTS = 0x2,
    CF_BOTH = 0x3,
    CF_FONTSHOWHELP = 0x4,
    CF_ENABLEHOOK = 0x8,
    CF_ENABLETEMPLATE = 0x10,
    CF_ENABLETEMPLATEHANDLE = 0x20,
    CF_INITTOLOGFONTSTRUCT = 0x40,
    CF_USESTYLE = 0x80,
    CF_EFFECTS = 0x100,
    CF_APPLY = 0x200,
    CF_ANSIONLY = 0x400,
    CF_NOVECTORFONTS = 0x800,
    CF_NOOEMFONTS = CF_NOVECTORFONTS,
    CF_NOSIMULATIONS = 0x1000,
    CF_LIMITSIZE = 0x2000,
    CF_FIXEDPITCHONLY = 0x4000,
    CF_WYSIWYG = 0x8000,
    CF_FORCEFONTEXIST = 0x10000,
    CF_SCALABLEONLY = 0x20000,
    CF_TTONLY = 0x40000,
    CF_NOFACESEL = 0x80000,
    CF_NOSTYLESEL = 0x100000,
    CF_NOSIZESEL = 0x200000,
    CF_SELECTSCRIPT = 0x400000,
    CF_NOSCRIPTSEL = 0x800000,
    CF_NOVERTFONTS = 0x1000000
} EChooseFont;


typedef enum EFontType {
    SIMULATED_FONTTYPE = 0x8000,
    PRINTER_FONTTYPE = 0x4000,
    SCREEN_FONTTYPE = 0x2000,
    BOLD_FONTTYPE = 0x100,
    ITALIC_FONTTYPE = 0x200,
    REGULAR_FONTTYPE = 0x400
} EFontType;

typedef enum EFORMAT_MESSAGE {
    FORMAT_MESSAGE_NONE             = 0x00000000,
    FORMAT_MESSAGE_ALLOCATE_BUFFER  = 0x00000100,
    FORMAT_MESSAGE_IGNORE_INSERTS   = 0x00000200,
    FORMAT_MESSAGE_FROM_STRING      = 0x00000400,
    FORMAT_MESSAGE_FROM_HMODULE     = 0x00000800,
    FORMAT_MESSAGE_FROM_SYSTEM      = 0x00001000,
    FORMAT_MESSAGE_ARGUMENT_ARRAY   = 0x00002000,
    FORMAT_MESSAGE_MAX_WIDTH_MASK   = 0x000000FF
} EFORMAT_MESSAGE;

// Browsing for directory.
typedef enum EBROWSEOPTIONS {

	[ helpstring("Only return directories--grey out OK button for other selections")]    
    BIF_RETURNONLYFSDIRS   = 0x0001,  // Find folder to start document search
	[ helpstring("Don't include network folders below the domain level")]    
    BIF_DONTGOBELOWDOMAIN  = 0x0002,  
	[ helpstring("Include a status area with text coming from messages sent by the callback function")]    
    BIF_STATUSTEXT         = 0x0004,
	[ helpstring("Only return file system ancestors--grey out OK button for other selections")]    
    BIF_RETURNFSANCESTORS  = 0x0008,
	[ helpstring("Include edit control for name of item")]    
	BIF_EDITBOX            = 0x0010,
	[ helpstring("Insist on valid result (or CANCEL)--requires will BIF_EDITBOX and callback procedure")]    
	BIF_VALIDATE           = 0x0020,  
	[ helpstring("Only return computers--grey out OK button for other selections")]  
    BIF_BROWSEFORCOMPUTER  = 0x1000,  
	[ helpstring("Only return printers--grey out OK button for other selections")]    
    BIF_BROWSEFORPRINTER   = 0x2000,  
	[ helpstring("Display files as well as folders")]    
    BIF_BROWSEINCLUDEFILES = 0x4000   
	
} EBROWSEOPTIONS;

typedef struct SHITEMID        // mkid
{
    LONG      cb;             // Size of the ID (including cb itself)
    BYTE        abID[1];        // The item ID (variable length)
} SHITEMID;

typedef struct ITEMIDLIST      // idl
{
    SHITEMID    mkid;
} ITEMIDLIST;

typedef struct BROWSEINFO {
    LONG        hwndOwner;
	LONG      pidlRoot;      //ITEMIDLIST  pidlRoot;
    LONG /* LPTSTR  */ pszDisplayName;// Return display name of item selected.
    LONG /* LPCTSTR */ lpszTitle; // text to go in the banner over the tree.
    LONG         ulFlags;   // Flags that control the return stuff
    LONG  lpfn;
    LONG         lParam;    // extra info that's passed back in callbacks
    LONG          iImage;    // output var: where to return the Image index.
} BROWSEINFO;

typedef enum ECSIDL {
	[ helpstring("SHGetSpecialFolderLocation: Desktop") ]
	CSIDL_DESKTOP         = 0x0000,
	[ helpstring("SHGetSpecialFolderLocation: Internet") ]
	CSIDL_INTERNET        = 0x0001, 
	[ helpstring("SHGetSpecialFolderLocation: Programs") ]
	CSIDL_PROGRAMS        = 0x0002,
	[ helpstring("SHGetSpecialFolderLocation: Control Panel") ]
	CSIDL_CONTROLS        = 0x0003,
	[ helpstring("SHGetSpecialFolderLocation: Printers") ]
	CSIDL_PRINTERS        = 0x0004,
	[ helpstring("SHGetSpecialFolderLocation: Documents") ]
	CSIDL_PERSONAL        = 0x0005,
	[ helpstring("SHGetSpecialFolderLocation: User's favorite items") ]
	CSIDL_FAVORITES       = 0x0006,
	[ helpstring("SHGetSpecialFolderLocation: Startup Directory") ]
	CSIDL_STARTUP         = 0x0007,
	[ helpstring("SHGetSpecialFolderLocation: Most Recently Used Documents") ]
	CSIDL_RECENT          = 0x0008,
	[ helpstring("SHGetSpecialFolderLocation: Send To Menu Items") ]
	CSIDL_SENDTO          = 0x0009,
	[ helpstring("SHGetSpecialFolderLocation: Recycle Bin") ]
	CSIDL_BITBUCKET       = 0x000a,
	[ helpstring("SHGetSpecialFolderLocation: Start Menu Directory") ]
	CSIDL_STARTMENU       = 0x000b,
	[ helpstring("SHGetSpecialFolderLocation: Desktop Directory") ]
	CSIDL_DESKTOPDIRECTORY  = 0x0010,
	[ helpstring("SHGetSpecialFolderLocation: My Computer") ]
	CSIDL_DRIVES          = 0x0011,
	[ helpstring("SHGetSpecialFolderLocation: Network Neighborhood") ]
	CSIDL_NETWORK         = 0x0012,
	[ helpstring("SHGetSpecialFolderLocation: Network Neighborhood Directory") ]
	CSIDL_NETHOOD         = 0x0013,
	[ helpstring("SHGetSpecialFolderLocation: Fonts") ]
	CSIDL_FONTS           = 0x0014,
	[ helpstring("SHGetSpecialFolderLocation: Templates") ]
	CSIDL_TEMPLATES       = 0x0015,
	[ helpstring("SHGetSpecialFolderLocation: Common Start Menu") ]
	CSIDL_COMMON_STARTMENU          = 0x0016,
	[ helpstring("SHGetSpecialFolderLocation: Common Programs") ] 
	CSIDL_COMMON_PROGRAMS           = 0X0017, 
	[ helpstring("SHGetSpecialFolderLocation: Common Startup") ]
	CSIDL_COMMON_STARTUP            = 0x0018,
	[ helpstring("SHGetSpecialFolderLocation: Common Desktop Directory") ]
	CSIDL_COMMON_DESKTOPDIRECTORY   = 0x0019,
	[ helpstring("SHGetSpecialFolderLocation: Common Application Data") ]
	CSIDL_APPDATA                   = 0x001a,
	[ helpstring("SHGetSpecialFolderLocation: Common Printer Neighborhood") ]
	CSIDL_PRINTHOOD                 = 0x001b,
	[ helpstring("SHGetSpecialFolderLocation: User's nonlocalized Startup program group") ]
	CSIDL_ALTSTARTUP                = 0x001d,         // DBCS 
	[ helpstring("SHGetSpecialFolderLocation: Common nonlocalized Startup program group") ]
	CSIDL_COMMON_ALTSTARTUP         = 0x001e,         // DBCS 
	[ helpstring("SHGetSpecialFolderLocation: Common favorite items") ]
	CSIDL_COMMON_FAVORITES          = 0x001f, 
	[ helpstring("SHGetSpecialFolderLocation: Temporary Internet files") ]
	CSIDL_INTERNET_CACHE            = 0x0020, 
	[ helpstring("SHGetSpecialFolderLocation: Internet cookies") ]
	CSIDL_COOKIES                   = 0x0021, 
	[ helpstring("SHGetSpecialFolderLocation: Internet history items") ]
	CSIDL_HISTORY                   = 0x0022
} ECSIDL;





//end HC types

   typedef [helpstring("CWP Type for Hooks")]  
   struct tagCWPSTRUCT{
	LONG lParam;
    	LONG wParam;
	LONG message;
	LONG hwnd;
    }CWPSTRUCT;

   typedef 
   struct _STARTUPINFO { 
    	LONG   cb; 
    	LPSTR  lpReserved; 
    	LPSTR  lpDesktop; 
    	LPSTR  lpTitle; 
    	LONG   dwX; 
    	LONG   dwY; 
    	LONG   dwXSize; 
    	LONG   dwYSize; 
    	LONG   dwXCountChars; 
    	LONG   dwYCountChars; 
    	LONG   dwFillAttribute; 
    	LONG   dwFlags; 
    	int    wShowWindow; 
    	int    cbReserved2; 
    	LONG  lpReserved2; 
    	LONG  hStdInput; 
    	LONG  hStdOutput; 
    	LONG  hStdError; 
   } STARTUPINFO;

typedef struct OSVERSIONINFO {
    LONG dwOSVersionInfoSize;
    LONG dwMajorVersion;
    LONG dwMinorVersion;
    LONG dwBuildNumber;
    LONG dwPlatformId;
    BYTE szCSDVersion[128];     // Maintenance string for PSS usage
} OSVERSIONINFO;

typedef struct SECURITY_ATTRIBUTES {
    LONG nLength;
    //[size_is(nLength)] LPVOID lpSecurityDescriptor;
    LONG lpSecurityDescriptor;
    bool bInheritHandle;
} SECURITY_ATTRIBUTES;

typedef struct SOCKADDR {
    short   sin_family;
    short   sin_port;
    LONG   sin_addr;
    BYTE   sin_zero[8];
} SOCKADDR;

typedef struct WSAData {
    short        wVersion;
    short       wHighVersion;
    BYTE  szDescription[256];       //szDescription[WSADESCRIPTION_LEN+1];
    BYTE  szSystemStatus[128];     //szSystemStatus[WSASYS_STATUS_LEN+1];
    short          iMaxSockets;
    short          iMaxUdpDg;
    LONG       lpVendorInfo;
} WSADATA; 

typedef struct HOSTENT {
    LONG   h_name;
    LONG   h_aliases;
    short   h_addrtype;
    short   h_length;
    LONG   h_addr_list;
} HOSTENT;

typedef struct  fd_set {
  LONG  fd_count;        // how many are SET?
  LONG  fd_array[64];  // an array of SOCKETs
} fd_set;



typedef struct StockData {
    BSTR   sDate;
    BSTR   sTime;
    DOUBLE   dOpen;
    DOUBLE   dHigh;
    DOUBLE   dLow;
    DOUBLE   dClose;
    LONG   iVol;
} StockData;

typedef struct PbButtonSpecs {
    BSTR   sCaption;
    LONG   iCaptionX;
    RECT   recButton;
} PbButtonSpecs;



//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
      // You need to define string constants in a module.
      // Modules also need to reference a dll name. In this case you don't
      // need to, so just give it a bogus name.

      [dllname("StringConst")]

      module StringConstants

       {

         // Define a constant mystr and assign it the value StringConstant.


const LPSTR sUnknownSymbol = "???";
//const LPSTR sEmpty = "";
const LPSTR sSettingChange = "Settings Change";
//const LPSTR sQuote2 = """";      
const LPSTR C_MDIFORMCLASS_IDE = "ThunderMDIForm";
const LPSTR C_MDIFORMCLASS_EXE = "ThunderRT6MDIForm";
const LPSTR C_MDIFORMCLASS5_IDE = "ThunderMDIForm";


	};

      

	// Now call a function located in the Windows API, specifically
      // User32.dll. Now you see why you need a dll name here, this is
      // where the API function will come from.
///////////////////////////////////////////////////////////////////////
      [dllname("user32.dll")]

      module user32Declare

       {

         // Give the API function a descriptive help line, this will
         // be seen in the Object browser. Then, you can declare the
         // function. The entry attribute specifies the identifier for the
         // entry point into the dll.
         // The in attribute specifies a parameter as a value going into
         // the function.



[
    usesgetlasterror,
    entry("GetCursorPos"),
    helpstring("Gets the mouse cursor position"),
    ]
	BOOL	 GetCursorPos(POINTL * lpPoint);


 [
    usesgetlasterror,
    entry("ClientToScreen"),
    helpstring("Converts client coordinates of specified point to screen coordinates"),
    ]
    BOOL  ClientToScreen(LONG hwnd, POINTL * lpPoint);

[
    usesgetlasterror,
    entry("SendMessageA"),
    helpstring(""),
    ]
    LONG   SendMessage (LONG hWnd,
						LONG wMsg,
						LONG wParam,
						LPSTR lParam);


[
    usesgetlasterror,
    entry("GetAsyncKeyState"),
    helpstring("Gets asynchronouse state of a Windows virtual keys"),
    ]
    LONG   GetAsyncKeyState(LONG nKeyState);

[
    usesgetlasterror,
    entry("ReleaseDC"),
    helpstring("Releases a DC obtained with GetDC or GetWindowDC"),
    ]
    LONG     ReleaseDC(LONG hwnd, LONG hdc);

[
    usesgetlasterror,
    entry("GetWindowDC"),
    helpstring("Gets entire DC of given window"),
    ]
    LONG     GetWindowDC(LONG hwnd);

[
    usesgetlasterror,
    entry("GetWindowLongA"),
    helpstring("Gets the indexed LONG data of a window handle (see GWL_ constants)")
    ]
    LONG    GetWindowLong(LONG hwnd, LONG nIndex);

[
    usesgetlasterror,
    entry("SetWindowPos"),
    helpstring("Changes the window size, position, and z-order of a window")
    ]
    BOOL    SetWindowPos(LONG hwnd, LONG hwndInsertAfter,
                                LONG x, LONG y,
                                LONG cx, LONG cy,
                                LONG fuFlags);



[
    usesgetlasterror,
    entry("GetClientRect"),
    helpstring("Retrieves coordinates of a window's client area")
    ]
    LONG    GetClientRect(LONG hwnd, RECT * lpRect);

[
    usesgetlasterror,
    entry("GetWindowRect"),
    helpstring("Retrieves coordinates of a window's bounding rectangle")
    ]
    LONG     GetWindowRect(LONG hwnd, RECT * lpRect);

[
    usesgetlasterror,
    entry("GetSystemMetrics"),
    helpstring("Get Various system metrics and system configuration settings"),
    ]
    LONG  GetSystemMetrics(LONG nIndex);

[
    usesgetlasterror,
    entry("ClipCursor"),
    helpstring("Confines the mouse cursor to a given rectangle"),
    ]
    BOOL  ClipCursor(LPVOID lpRect);

[
    usesgetlasterror,
    entry("SetCursorPos"),
    helpstring("Sets the mouse cursor position"),
    ]
    LONG    SetCursorPos(LONG x, LONG y);

[
    usesgetlasterror,
    entry("GetClipCursor"),
    helpstring("Gets the rectangle where the mouse cursor is confined"),
    ]
    BOOL  GetClipCursor(RECT * lpRect);

[
    usesgetlasterror,
    entry("ShowCursor"),
    helpstring("Show or hide the mouse cursor"),
    ]
    LONG     ShowCursor(BOOL bShow);

[
    usesgetlasterror,
    entry("InflateRect"),
    helpstring("Increases or decreases the width and height of the specified rectangle, adding dx units to the left and right ends and dy units to the top and bottom (signed dx and dy increase the width and height when positive, and decrease when negative)"),
    ]
	BOOL  InflateRect(RECT * lpRect, LONG x, LONG y);

[
    usesgetlasterror,
    entry("DrawEdge"),
    helpstring("Draws a 3-D edge on a rectangle according to the given edge and border flags"),
    ]
    BOOL  DrawEdge(LONG hdc, RECT * lpRect,
                         LONG edge, LONG grfFlags);

[
    usesgetlasterror,
    entry("DrawFrameControl"),
    helpstring("Draws a control frame of a specified type and style"),
    ]
    BOOL  DrawFrameControl(LONG hdc, RECT * lpRect,
                                 LONG uType, LONG uState);

[
    usesgetlasterror,
    entry("UpdateWindow"),
    helpstring("Updates the client area of the specified window"),
    ]
    BOOL    UpdateWindow(LONG hWnd);

[
    usesgetlasterror,
    entry("GetDC"),
    helpstring("Gets client area DC of given window"),
    ]
    LONG    GetDC(LONG hwnd);

[
    usesgetlasterror,
    entry("DrawStateA"),
    helpstring("Displays an image and applies a visual effect to indicate a state, such as a disabled or default state"),
    ]
	BOOL DrawState(LONG hDC, LONG hbr, 
						  LONG  lpDrawStateProc, 
						  LONG lParam, LONG wParam, 
						  LONG x, LONG y, LONG cx, LONG cy, LONG fuFlags);

[
    usesgetlasterror,
    entry("SetWindowRgn"),
    helpstring("The SetWindowRgn function sets the window region of a window. The window region determines the area within the window where the system permits drawing"),
    ]
	LONG SetWindowRgn(LONG hWnd, LONG hRgn, BOOL bRedraw);

[
    usesgetlasterror,
    entry("GetSysColor"),
    helpstring("Returns color of the specified display element"),
    ]
    LONG GetSysColor(LONG nIndex);

[
    usesgetlasterror,
    entry("GetDesktopWindow"),
    helpstring("Returns handle of desktop window"),
    ]
    LONG    GetDesktopWindow();

[
    usesgetlasterror,
    entry("DrawTextExA"),
    helpstring("(ANSII)-Copies the text of item idItem (according to fuFlags) in menu hMenu into the buffer lpsz"),
    ]
	LONG DrawTextEx(LONG hDC, LPSTR lpsz, LONG n, 
						  RECT * lpRect, LONG dwDTFormat, 
						  DRAWTEXTPARAMS *lpDTParams);



   
   [helpstring("User32 Hook Declare"), entry("SetWindowsHookExA")]    LONG
   SetWindowsHookEx(
		LONG idHook,
		LONG lpfn,
		LONG hmod,
		LONG dwThreadId);
   

   [helpstring("User32 unHook Declare"), entry("UnhookWindowsHookEx")]    LONG
   UnhookWindowsHookEx( 
		LONG hHook); 





       };

///////////////////////////////////////////////////////////////////////
      [dllname("gdi32.dll")]

      module gdi32Declare

       {



 [
    usesgetlasterror,
    entry("GetCharWidth32A"),
    helpstring("Retrieves the widths, in logical coordinates, of consecutive characters in a specified range from the current font"),
    ]
    BOOL   GetCharWidth32(LONG hdc,
	 						    LONG iFirstChar, 
							    LONG iLastChar, 
								LONG * lpBuffer);


[
    usesgetlasterror,
    entry("BitBlt"),
    helpstring("Combines source, destination, and pattern of two DCs according to ROP mode"),
    ]
    BOOL     BitBlt(LONG hdcDest,
                          LONG nXDest, LONG nYDest,
                          LONG nWidth, LONG nHeight,
                          LONG hdcSrc,
                          LONG nXSrc, LONG nYSrc,
                          LONG dwRop);

[
    usesgetlasterror,
    entry("StretchDIBits"),
    helpstring("Copies the color data for a rectangle of pixels in a device-independent bitmap (DIB) to the specified destination rectangle"),
    ]
    LONG    StretchDIBits(LONG hdc, 
							   LONG XDest,	
							   LONG YDest,	
							   LONG nDestWidth,	
							   LONG nDestHeight,	
							   LONG XSrc,	
							   LONG YSrc,	
							   LONG nSrcWidth,	
							   LONG nSrcHeight,	
                               LPVOID lpBits,
                               BITMAPINFO lpBitsInfo,
							   LONG iUsage,	
							   LONG dwRop);

[
    usesgetlasterror,
    entry("ExtCreateRegion"),
    helpstring("Creates a region from the specified region and transformation data"),
    ]
    LONG ExtCreateRegion(LONG  lpXform,
								LONG nCount,
								LPVOID  lpRgnData);

[
    usesgetlasterror,
    entry("SelectObject"),
    helpstring("Selects a given GDI object into a DC, returning the previous object"),
    ]
    LONG SelectObject(LONG hdc, LONG hObject);



[
    usesgetlasterror,
    entry("SetBkMode"),
    helpstring("Set the background mode of a DC"),
    ]
    LONG   SetBkMode(LONG hdc, LONG fnBkMode);

[
    usesgetlasterror,
    entry("SetTextColor"),
    helpstring("Sets the text (foreground) color of a DC"),
    ]
    LONG SetTextColor(LONG hdc, LONG clrref);

[
    usesgetlasterror,
    entry("SetROP2"),
    helpstring("Sets the current foreground mix mode"),
    ]
    LONG   SetROP2(LONG hdc, LONG fnDrawMode);

[
    usesgetlasterror,
    entry("GetTextExtentPoint32A"),
    helpstring("Computes the width and height of the specified string of text"),
    ]
    BOOL  GetTextExtentPoint32(LONG hdc, LPSTR lpString, 
									    LONG cbString, SIZEL * lpSize);


[
    usesgetlasterror,
    entry("SetGraphicsMode"),
    helpstring("Sets the graphics mode for the specified device context"),
    ]
    LONG    SetGraphicsMode(LONG hdc, LONG iMode);

[
    usesgetlasterror,
    entry("Rectangle"),
    helpstring("Draws rectangle around given points with current pen filled with current brush"),
    ]
    BOOL    Rectangle(LONG hdc,
                            LONG X1, LONG Y1,
							LONG X2, LONG Y2);

[
    usesgetlasterror,
    entry("Ellipse"),
    helpstring("Draws ellipse bounded by given points with current pen and filled with current brush"),
    ]
    BOOL    Ellipse(LONG hdc,
                           LONG X1, LONG Y1,
                           LONG X2, LONG Y2);

[
    usesgetlasterror,
    entry("CreatePen"),
    helpstring("Creates a logical pen that has the specified style, width, and color"),
    ]
    LONG CreatePen(LONG fnPenStyle, LONG nWidth, LONG crColor);

[
    usesgetlasterror,
    entry("CreateCompatibleDC"),
    helpstring("Creates a memory DC compatible with a given DC"),
    ]
    LONG  CreateCompatibleDC(LONG hdc);

[
    usesgetlasterror,
    entry("CreateDIBSection"),
    helpstring("Creates a device-independent bitmap (DIB) that applications can write to directly"),
    ]
    LONG CreateDIBSection(LONG hdc, 
                            BITMAPINFO * pBitmapInfo,
							LONG iUsage,	
							LONG lplpVoid,	
							LONG hHandle,
							LONG dwOffset);

[
    usesgetlasterror,
    entry("StretchBlt"),
    helpstring("Combines select brush and destination pattern on DC according to ROP mode while changing size"),
    ]
    BOOL  StretchBlt(LONG hdcDest,
                       LONG nXOriginDest, LONG nYOriginDest,
                       LONG bWidthDest, LONG nHeightDest,
                       LONG hdcSrc,
                       LONG nXOriginSrc, LONG nYOriginSrc,
                       LONG nWidthSrc, LONG nHeightSrc,
                       LONG dwRop);

[
    usesgetlasterror,
    entry("GetDIBits"),
    helpstring("Retrieves the bits of the specified bitmap and copies them into a buffer using the specified format"),
    ]
    LONG   GetDIBits(LONG hdc, 
				   LONG hbm, 
				   LONG uStartScan, 
				   LONG cScanLines, 
                   LPVOID lpvBits,
                   BITMAPINFO * lpbi,
				   LONG uUsage);


[
    usesgetlasterror,
    entry("DeleteObject"),
    helpstring("Deletes a given GDI object"),
    ]
    BOOL   DeleteObject(LONG hgdiobj);

[
    usesgetlasterror,
    entry("DeleteDC"),
    helpstring("Deletes a given DC"),
    ]
    BOOL  DeleteDC(LONG hdc);

//	[helpstring("gdi32 Declare GetTextMetrics "), entry("GetTextMetricsA")]  LONG
//	GetTextMetrics(
//		[in] LONG   hDC, 
//		[in,out] TEXTMETRIC  *lpMetrics);




////template/////       [helpstring("gdi32 Declare  "), entry("SetWindowRgn")]  LONG
	};

///////////////////////////////////////////////////////////////////////
      [dllname("kernel32.dll")]

      module kernel32Declare

       {


[
    usesgetlasterror,
    entry("lstrcatA"),
    helpstring("Joins 2 strings"),
    ]
    LONG  lstrcat(LPSTR lpString1, LPSTR lpString2);


[
    usesgetlasterror,
    entry("CreateFileA"),
    helpstring("Creates or opens a file, pipe, communications resource, disk device, console, or directory"),
    ]
    LONG  CreateFile(LPSTR lpFileName,
                                LONG dwDesiredAccess,
                                LONG dwShareMode,
							    LONG  lpSecurityAttributes,
                                LONG dwCreationDisposition,
                                LONG dwFlagsAndAttributes,
                                LONG hTemplateFile);


[
    usesgetlasterror,
    entry("GetPrivateProfileStringA"),
    helpstring("Gets a key value from given entry within given section of INI file (or default if not found)"),
    ]
    LONG     GetPrivateProfileStringKeys(LPSTR lpszSection,
                                           LONG lpszKey,
                                           LPSTR lpszDefault,
                                           LPSTR lpszReturnBuffer,
                                           LONG cbReturnBuffer,
                                           LPSTR lpszFilename);


[
    usesgetlasterror,
    entry("GetPrivateProfileStringA"),
    helpstring("Gets a string value from given entry within given section of INI file (or default if not found)"),
    ]
    LONG     GetPrivateProfileString(LPSTR lpszSection,
                                           LPSTR lpszEntry,
                                           LPSTR lpszDefault,
                                           LPSTR lpszReturnBuffer,
                                           LONG cbReturnBuffer,
                                           LPSTR lpszFilename);




[
    usesgetlasterror,
    entry("WritePrivateProfileStringA"),
    helpstring("Writes given string value to given entry within given section of INI file"),
    ]
    BOOL    WritePrivateProfileString(LPSTR lpszSection,
                                             LPSTR lpszEntry,
                                             LPSTR lpszString,
                                             LPSTR lpszFilename);



[
	usesgetlasterror,
	entry("GetCurrentThreadId"),
	helpstring("Returns the thread identifier of the calling thread")
    ]
	LONG  GetCurrentThreadId(void);

[
    usesgetlasterror,
    entry("GetSystemInfo"),
    helpstring("Returns information about the current system"),
    ]
    void GetSystemInfo(SYSTEM_INFO * lpSystemInfo);

[
    usesgetlasterror,
    entry("GlobalMemoryStatus"),
    helpstring("Obtains information about the system's current use of physical and virtual memory"),
    ]
    void GlobalMemoryStatus(MEMORYSTATUS * lpBuffer);

[
    usesgetlasterror,
    entry("GetComputerNameA"),
    helpstring("Gets the computer (machine) name"),
    ]
    LONG GetComputerName(LPSTR lpBuffer,
                                LONG * nSize);

[
    usesgetlasterror,
    entry("QueryPerformanceCounter"),
    helpstring("Retrieves value of the high-resolution performance counter"),
    ]
    BOOL QueryPerformanceCounter(LARGE_INTEGER lpPerformanceCount);

[
    usesgetlasterror,
    entry("QueryPerformanceFrequency"),
    helpstring("Retrieves frequency of the high-resolution performance counter"),
    ]
    BOOL QueryPerformanceFrequency(LARGE_INTEGER lpFrequency);

[
    usesgetlasterror,
    entry("GetVersionExA"),
    helpstring("Gets Windows version information"),
    ]
    BOOL GetVersionEx(OSVERSIONINFO * lpVersionInformation);

[
    entry("RtlMoveMemory"),
    helpstring("Copies memory from source to destination by reference"),
    ]
    void  CopyMemory(LPVOID pvDst,
                           LPVOID pvSrc, LONG cbCopy);

[
    helpstring("Copies memory from source string to destination by reference"),
	entry("RtlMoveMemory")
    ]
    void CopyMemoryStr(LPVOID pvDst,
					  LPSTR pvSrc, LONG cbCopy);

[
    usesgetlasterror,
    entry("GlobalAlloc"),
    helpstring("Allocate global memory"),
    ]
    LONG GlobalAlloc(LONG wFlags, LONG dwBytes);


[
    usesgetlasterror,
    entry("GlobalLock"),
    helpstring("Locks global memory block and returns pointer to it"),
    ]
    LONG GlobalLock(LONG hMem);

[
    usesgetlasterror,
    entry("GlobalUnlock"),
    helpstring("Unlocks global memory block"),
    ]
    BOOL    GlobalUnlock(LONG hMem);

[
    usesgetlasterror,
    entry("GlobalFree"),
    helpstring("Free global memory block"),
    ]
    LONG  GlobalFree(LONG hMem);

[
    usesgetlasterror,
    entry("lstrlenA"),
    helpstring("Returns length of string (from byte array)"),
    ]
    int    lstrlenByte(BYTE * lpsz);

[
    usesgetlasterror,
    entry("GetFullPathNameA"),
    helpstring("Returns full path of lpFileName in lpBuffer and lpFilePart"),
    ]
    LONG GetFullPathName(LPSTR lpFileName,
                                 LONG nBufferLength,
                                 LPSTR lpBuffer,
                                 LONG *lpFilePart);

[
    usesgetlasterror,
    entry("lstrlenA"),
    helpstring("Returns length of string (from string)"),
    ]
    int     lstrlen(LPSTR lpsz);

[
    usesgetlasterror,
    entry("FormatMessageA"),
    helpstring("Formats a message string from a message definition (usally located in a DLL)"),
    ]
    LONG  FormatMessage(
        EFORMAT_MESSAGE dwFlags,
        LONG /* LPVOID */ lpSource,
        LONG dwMessageId,
        LONG dwLanguageId,
        LPSTR lpBuffer,
        LONG nSize,
        LPVOID /* va_list * */ Arguments);



	[helpstring("kernel32 Declare "), entry("CreateEventA")]  LONG
	CreateEvent(
		[in] LONG  lpEventAttributes, 	
		[in] LONG  bManualReset, 
		[in] LONG  bInitialState, 	
		[in] LPSTR lpName);

	[helpstring("kernel32 Declare "), entry("ResetEvent")]  LONG
	ResetEvent(
		[in] LONG  hEvent);

	[helpstring("kernel32 Declare "), entry("SetEvent")]  LONG
	SetEvent(
		[in] LONG  hEvent);






////template/////       [helpstring("kernel32 Declare "), entry("SetWindowRgn")]  LONG
	};
   
///////////////////////////////////////////////////////////////////////
      [dllname("wsock32.dll")]

      module wsock32Declare

       {



	[entry("select")]
		LONG	vbselect(
					LONG nfds,
					LPVOID readfds,
					LPVOID writefds,
					LPVOID exceptfds,
					LONG timeout);



	[entry("recv")]
		LONG	recv(
					LONG s ,
					LPVOID buf, 
					LONG buflen,
					LONG flags);



	[entry("send")]
		LONG	send(
					LONG s,
					LPVOID buf,
					LONG buflen, 
					LONG flags);


	[entry("WSAStartup")]
		LONG	WSAStartup(
						LONG  wVR, 
						WSAData * lpWSAD);


	[entry("WSACancelBlockingCall")]
		LONG	WSACancelBlockingCall();


	[entry("WSAIsBlocking")]
		LONG	WSAIsBlocking();


	[entry("WSAAsyncSelect")]
		LONG	WSAAsyncSelect(
						LONG s, 
						LONG hWnd,
						LONG wMsg,
						LONG lEvent);


	[entry("closesocket")]
		LONG	CloseSocket(LONG  s);


	[entry("connect")]
		LONG	Connect(
						LONG s , 
						sockaddr * addr, 
						LONG namelen);


	[entry("htons")]
		short	htons(LONG hostshort);

	[entry("socket")]
		LONG	Socket(
						LONG af, 
						LONG s_type, 
						LONG protocol);


	[helpstring("wsock32 Declare "), entry("WSAGetLastError")]  
		LONG  	WSAGetLastError();

/*	[helpstring("wsock32 Declare "), entry("WSAStartup")]  
		LONG  	WSAStartup(
        				LONG wVersionRequired, 
						WSAData *lpWSADATA);
*/
	[helpstring("wsock32 Declare "), entry("WSACleanup")]  
		LONG	WSACleanup();

	[helpstring("wsock32 Declare "), entry("gethostname")]  
		LONG	gethostname(
        				LPSTR szHost, 
						LONG dwHostLen);

	[helpstring("wsock32 Declare "), entry("gethostbyname")]  
		LONG	gethostbyname(
						LPSTR szHost);

	[helpstring("wsock32 Declare "), entry("gethostbyaddr")]  
		LONG	gethostbyaddr(
						 LONG  dwHost, 
						 int  hLen, 
						 int aType);

	[helpstring("wsock32 Declare "), entry("inet_addr")]  
		LONG	inet_addr(
						LPSTR szHost);


////template/////       [helpstring("wsock32 Declare "), entry("SetWindowRgn")]  LONG
	};

///////////////////////////////////////////////////////////////////////
      [dllname("COMDLG32.dll")]

      module COMDLG32Declare

       {


[helpstring("ChooseColor Dialog box Declare "), entry("ChooseColorA")]
LONG  ChooseColor(TCHOOSECOLOR * Color);

[helpstring("ChooseFont Dialog box Declare "), entry("ChooseFontA")]
LONG  ChooseFont(TCHOOSEFONT * chfont);

	};



///////////////////////////////////////////////////////////////////////
      [dllname("SHELL32.DLL")]

      module SHELL32Declare

       {


   //-------------------------------------------------------------------------
    //
    // SHBrowseForFolder API
    //
    //-------------------------------------------------------------------------

    
	[
    usesgetlasterror,
    entry("SHGetPathFromIDListA"),
    helpstring("Converts an item ID list pointer to a file system path (cMaxPath buffer expected)"),
    ]
    BOOL  SHGetPathFromIDList(LONG pidl, LPSTR pszPath);



    [
    usesgetlasterror,
    entry("SHBrowseForFolder"),
    helpstring("Displays a dialog that allows selection of shell folders"),
    ]
    LONG  SHBrowseForFolder(BROWSEINFO * lpbi);

	};

///////////////////////////////////////////////////////////////////////
      [dllname("wininet.dll")]

      module wininetDeclare

       {

	[
    usesgetlasterror,
    entry("InternetGetConnectedState"),
    helpstring(""),
    ]
    LONG  InternetGetConnectedState(
								LONG * lpdwFlags,
								LONG dwReserved);



	};



}
